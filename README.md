# アルゴリズムとデータ構造

## 整列アルゴリズム

- 挿入ソート

  - 計算量：O(n^2)

  - 要素数が少ない、初めからほぼ整列している状態に使う

  - 配列を左（整列済み）と右（未整列）に分けて、行う整列アルゴリズム

    - 仕組み

    1. 左側を整列する（この時点で要素数は２）
    2. 左側の整列が終わると、右側の要素一つを左側に加えて再度整列する
    3. 右側の要素がなくなるまで2を繰り返す

- 選択ソート

  - 計算量：O(n^2)

  - 最遅ので普通は使わない

  - 未整列の配列から、最小を探し、整列済みに加える整列アルゴリズム

    - 仕組み

    1. 1番目の要素から最後尾の要素までで最も値の小さいものを探し、それを1番目の要素と交換する
    2. 以降同様に、未ソート部分の最小要素を探索し、未ソート部分の先頭要素と交換する
    3. すべての要素がソート済みになったら処理を終了する

- ヒープソート

  - 計算量：O(n log n)
  - クイックソートの次に優秀な整列アルゴリズム
  - クイックソートが上手くいかない状況の多くを回避できるが、クイックソートよりは少し性能が低い

- クイックソート

  - 計算量：O(n log n)、最悪：O(n^2)
  - 最速の整列アルゴリズム
  - 仕組み

  1. 対象の配列をパーティションによって、左右２つの部分配列へと分割
  2. 1で分割した部分配列のうち、左側の配列に対してquickSortを行う
  3. 1で分割した部分配列のうち、右側の配列に対してquickSortを行う
  4. 1~3を整列終了まで繰り返す

- バケツソート

  - 計算量：O(n)
  - 決められた範囲内の数列にしか使えない整列アルゴリズム（実実装）
  - 仕組み

  1. 決められた範囲内の辞書を用意しておき、未整列の配列祖うそを全て、辞書に入れる。
  2. 辞書に入っている要素のみを順にとりだす

- マージソート

  - 計算量：O(n^2)
  - クイックソートと同様、分割統治法を用いてソートを行うアルゴリズム
  - 仕組み

  1. 集合を中央で２つに分割する
  2. 分割後の各集合のデータをそれぞれソートする
  3. ソート済みの各集合の小さいデータから順に新しい集合にコピーしてマージする
  4. 2~3を整列終了まで繰り返す



## 探索アルゴリズム

- 逐次ソート
  - 計算量：O(n）
  - 前から順に探索するアルゴリズム
- 二分探索
  - 計算量：O(log n)
  - 整列済みだと逐次探索よりも早い
- ハッシュ法を用いた探索
  - 計算量：O(n)、O(1)
  - 整列の有無を問わない探索アルゴリズム
- ブルームフィルタ
  - 計算量：O(log k)
  - よくわからない探索アルゴリズム
- 二分探索木
  - 二木探索が進化したアルゴリズム



## グラフアルゴリズム

- 深さ優先探索
  - 計算量：O(V + E)
  - 木やグラフを探索するためのアルゴリズム
- 幅優先探索
  - 計算量：O(V + E)
  - グラフ理論において木構造やグラフの探索に用いられるアルゴリズム


## Reference

1. Book
   - O'Reilly Japan - アルゴリズムクイックリファレンス

2. Site
   - [Go言語で基本のソートアルゴリズムを実装してみた][1]
   - [【Go】Sorting algorithms (ソートアルゴリズム)][2]
   - [Qiita amesho][3]
   - [Qiita miyyuk][4]

<!--LINK-->

[1]:https://blog.lab.sugimototatsuo.com/entry/2022/05/07/114032
[2]:https://qiita.com/miyyuk/items/85c2ed8176e9bdf7e677
[3]:https://qiita.com/amesho
[4]:https://qiita.com/miyyuk
